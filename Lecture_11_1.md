# ภาษาซีสำหรับไมโครคอนโทรลเลอร์ (I)

## เฟิร์มแวร์แรก - first.c

1. เสียบบอร์ด MCU เข้ากับอุปกรณ์ Raspberry Pi
2. สร้างไดเรคตอรี practicum/mcu ไว้ภายใต้โฮมไดเรคตอรีของตน (ใช้อ็อปชัน -p เพื่อสร้างไดเรคตอรีก่อนหน้าให้อัตโนมัติหากไม่มีอยู่แล้ว)

```bash
mkdir -p practicum/mcu
cd practicum/mcu
```

3. สร้างไฟล์ first.c ขึ้นในไดเรคตอรีปัจจุบันด้วยคำสั่ง nano หรือ vi
```
nano first.c
```
4. ป้อนโค้ดดังนี้
```c
#define F_CPU 16000000   // ระบุว่า MCU ทำงานที่ 16MHz (เพื่อให้โค้ดหน่วงเวลาทำงานถูกต้อง)
#include <avr/io.h>      // โหลดนิยามสำหรับรีจีสเตอร์ที่ควบคุมอินพุท/เอาท์พุท (เช่น PORTD, DDRD)
#include <util/delay.h>  // โหลดนิยามสำหรับฟังก์ชัน _delay_ms()


int main()
{
    DDRD  = 0b00001000;  // กำหนดให้ขา PD3 ทำหน้าที่เอาท์พุท
    PORTD = 0b00000000;  // กำหนดลอจิกขา PD7..0 เป็น 0


    while (1)
    {
        PORTD = 0b00001000;  // ส่งลอจิก 1 ไปที่ขา PD3
        _delay_ms(1000);     // หน่วงเวลารอ 1000 มิลลิวินาที
        PORTD = 0b00000000;  // ส่งลอจิก 0 ไปที่ขา PD3
        _delay_ms(1000);     // หน่วงเวลารอ 1000 มิลลิวินาที
    }
}
```

รายละเอียดของโปรแกรมข้างต้นเป็นดังนี้
- โปรแกรมเรียกใช้นิยามชื่อรีจีสเตอร์ (PORTD, DDRD ฯลฯ) จากไฟล์เฮดเดอร์ `avr/io.h` และฟังก์ชันหน่วงเวลา `_delay_ms()` จากไฟล์เฮดเดอร์ `util/delay.h`
- ตัวเลขที่นำหน้าด้วย `0b` ในโค้ดภาษาซีเป็นการบอกให้คอมไพเลอร์ตีความค่าตัวเลขที่ตามมาให้เป็นตัวเลขฐานสอง ดังนั้น `0b00001000`จึงมีค่าเท่ากับ `8` (ฐานสิบ) นอกจากเลขฐานสองแล้วภาษาซียังรองรับการระบุค่าจำนวนเต็มคงที่ในรูปฐานแปด (ขึ้นต้นด้วย `0`) และฐานสิบหก (ขึ้นต้นด้วย `0x`)

5. คอมไพล์โปรแกรม first.c ให้เป็นภาษาเครื่อง โดยพิมพ์คำสั่งลงในเชลล์
```
avr-gcc -mmcu=atmega328p -O -o first.elf first.c
```
อ็อพชันต่าง ๆ ที่ระบุในคำสั่งข้างต้นมีหน้าที่ดังนี้
- `-mmcu=atmega328p` เป็นตัวบอกคอมไพเลอร์ว่าไมโครคอนโทรลเลอร์ที่ใช้เป็นเบอร์ ATMega328P
- `-O` ระบุให้ทำ code optimization ซึ่งจำเป็นต้องใช้เพื่อให้ฟังก์ชัน _delay_ms() ทำงานได้ถูกต้อง
- `-o first.elf` ระบุว่าให้เอาท์พุทถูกเก็บลงในไฟล์ชื่อ first.elf หากไม่ระบุโปรแกรมจะสร้างไฟล์ชื่อ `a.out` แทน

6. ผลลัพธ์ที่ได้จากการคอมไพล์จะอยู่ในรูปของไฟล์ฟอร์แมต `ELF (Excutable and Linkable Format)`

```
avr-objcopy -j .text -j .data -O ihex first.elf first.hex
```

อ็อพชันต่าง ๆ ที่ระบุในคำสั่งข้างต้นมีหน้าที่ดังนี้
- `-j .text -j .data` สกัดข้อมูลจากเซคชัน .text (ส่วนของโค้ดโปรแกรม) และ .data (ส่วนของข้อมูลที่กำหนดค่าเริ่มต้นให้ตัวแปร) ออกมาจากไฟล์ ELF
- `-O ihex` บันทึกเอาท์พุทในรูปแบบ Intel HEX


## การโหลดโปรแกรมลงบนหน่วยความจำแฟลชของไมโครคอนโทรลเลอร์

- เสียบจั๊มเปอร์เพื่อชอร์ตวงจรในตำแหน่งที่ระบุว่า Boot-loader บนบอร์ด ซึ่งตรงกับขา PD7 จากนั้นกดปุ่ม Reset เพื่อเข้าสู่บูตโหลดเดอร์

```
lsusb
:
Bus xxx Device xxx: ID 16c0:05dc Van Ooijen Technische Informatica shared ID ...
:
```
ใช้คำสั่ง avrdude เพื่อส่งโปรแกรมไปยังไมโครคอนโทรลเลอร์ผ่านพอร์ท USB

```
avrdude -p atmega328p -c usbasp -U flash:w:first.hex
```

## การสร้างกระบวนการอัตโนมัติด้วย Makefile

- ครอสคอมไพล์โปรแกรมด้วยคำสั่ง `avr-gcc`
- สกัดรหัสภาษาเครื่องจากไฟล์ `.elf` ด้วยคำสั่ง `avr-objcopy`
- ส่งรหัสภาษาเครื่องไปยังไมโครคอนโทรลเลอร์ด้วยคำสั่ง `avrdude`

ในแต่ละขั้นตอนมีการใช้คำสั่งที่ค่อนข้างยาว เป็นการเสียเวลาและผิดพลาดได้ง่ายหากต้องพิมพ์ใหม่ทุกครั้ง ยูนิกซ์มีคำสั่ง make ที่ช่วยเรียกคำสั่งเหล่านี้ให้อัตโนมัติ 

### ตัวอย่าง Makefile

```Makefile
TARGET=first.hex
MCU=atmega328p
F_CPU=16000000
CFLAGS=-mmcu=$(MCU) -Os -DF_CPU=$(F_CPU)
OBJS=


all: $(TARGET)


%.flash: %.hex
	avrdude -p $(MCU) -c usbasp -U flash:w:$<


%.hex: %.elf
	avr-objcopy -j .text -j .data -O ihex $< $@


%.elf: %.o $(OBJS)
	avr-gcc $(CFLAGS) -o $@ $^


%.o: %.c
	avr-gcc $(CFLAGS) -c -o $@ $<


clean:
	rm -f *.o *.elf *.hex

```
